#!/usr/bin/env -S stap -g --all-modules

%{ /* pure */
#include <net/route.h>
#include <linux/skbuff.h>
#include <linux/icmp.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
%}

function __skb_linear_data:long(skb:long, offset:long)
%{ /* pure */
   struct sk_buff *skb;
   uintptr_t buf;

   skb = (struct sk_buff *)(uintptr_t)STAP_ARG_skb;

   kderef_buffer(NULL, skb, sizeof(struct sk_buff));
   buf = (uintptr_t)((char *)skb_mac_header(skb) + STAP_ARG_offset);
   STAP_RETVALUE = *(unsigned int *)buf;
   CATCH_DEREF_FAULT();
%}

function __skb_len:long(skb:long)
%{ /* pure */
   struct sk_buff *skb;

   skb = (struct sk_buff *)(uintptr_t)STAP_ARG_skb;

   STAP_RETVALUE = skb->len;
   CATCH_DEREF_FAULT();
%}

function __get_skb_icmphdr:long(skb:long)
%{ /* pure */
   struct sk_buff *skb;
   skb = (struct sk_buff *)(uintptr_t)STAP_ARG_skb;

   kderef_buffer(NULL, skb, sizeof(struct sk_buff));
   STAP_RETVALUE = (long)skb_network_header(skb) + sizeof(struct iphdr);
   CATCH_DEREF_FAULT();
%}

@define icmphdr_cast(ptr) %(
        @cast(@ptr, "icmphdr", "kernel<uapi/linux/icmp.h>")
%)

function __icmp_code:long (icmphdr)
{
  return @icmphdr_cast(icmphdr)->code
}

function __icmp_type:long (icmphdr)
{
  return @icmphdr_cast(icmphdr)->type
}

probe kernel.{function("dev_set_mtu"),function("change_mtu")} {
	name = get_netdev_name($dev);
        old = $dev->mtu;
	printf("[%d] (%s:%d) device %s change mtu from %d to %d\n", ktime_get_ns(), execname(), pid(), name, old, $new_mtu);
	print_backtrace();
}

function skb_linear_print (skb)
{
        skb_len_to_print = __skb_len(skb);
        skb_len = __skb_len(skb);

        while (skb_len_to_print) {
            next_batch = skb_len_to_print;
            if (next_batch < 8) {
                next_batch = 0;
            } else {
                next_batch -= 8;
            }
            printf("0x%08x:   ", skb_len - skb_len_to_print);

            while (skb_len_to_print > next_batch) {
                printf(" 0x%08x", __skb_linear_data(skb, skb_len - skb_len_to_print));
                skb_len_to_print -= 1;
            }
            printf("\n");
        }
}

probe kernel.{function("icmp_rcv"),function("icmp_unreach"),function("icmp_reply"),function("ipv4_update_pmtu"),function("ip_rt_update_pmtu"),function("ipv4_sk_update_pmtu")} {
            skb = $skb;
            icmphdr = __get_skb_icmphdr(skb);
            code = __icmp_code(icmphdr);
            type = __icmp_type(icmphdr);

            printf("[%d] Handle possible RT Exception (%s, %d, %d)\n", ktime_get_ns(), probefunc(), type, code);
            if (probefunc() =~ "icmp_reply.*") {
               printf("Generic ICMP (%u) %d:%d\n", uid(), code, type);
            } else {
              if (code == 3) {
                  printf("Unreachable message in (%s:%d %d/%d)\n", execname(), pid(), type, code);
                  print_backtrace();
                  printf("====================================\n");
                  printf("skb: indev[%s]\n", kernel_string($skb->dev->name));
                  skb_linear_print(skb);
                  printf("====================================\n");
              }
            }
}

probe kernel.{function("fib_table_insert"),function("fib_table_delete")} {
	cfg = $cfg;
	printf("[%d] FIB table insert/delete called with gw: %08x / %08x", ktime_get_ns(), cfg->fc_dst, cfg->fc_gw);
	print_backtrace();
}

/* probe kernel.function("icmp_send") {
      skb = $skb_in;
      type = $type;
      code = $code;
      //printf("Gen possible RT Exception (%s, %d, %d)\n", probefunc(), type, code);
      if (type == 4 && code == 3) {
          printf("Generated by (%s:%d)", execname(), pid());
          print_backtrace();
      }
}*/

